#!/bin/bash

BUILD_ROOT=$(realpath "${BASH_SOURCE[0]%/*}/..")
source "$BUILD_ROOT/helpers/message-helpers.sh"
source "$BUILD_ROOT/helpers/paths.sh"

TEMP_DIR=$(mktemp -d)

trap "rm -rf $TEMP_DIR" EXIT

# Default tier
TIER=""
SPECIFIC_PACKAGES=()

# Parse arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    --tier)
      TIER="$2"
      if [[ "$TIER" != "edge" && "$TIER" != "shared" ]]; then
        print_error "Invalid tier: $TIER (must be 'edge' or 'shared')"
        exit 1
      fi
      shift 2
      ;;
    -h|--help)
      echo "Usage: $0 --tier <edge|shared> [PACKAGE...]"
      echo ""
      echo "Sync AUR packages to pkgbuilds/<tier>/ directory"
      echo ""
      echo "Options:"
      echo "  --tier <tier>  Target tier: edge or shared (required)"
      echo ""
      echo "Arguments:"
      echo "  PACKAGE    One or more package names to sync (optional)"
      echo ""
      echo "Examples:"
      echo "  $0 --tier edge              # Sync all packages from edge.packages"
      echo "  $0 --tier shared            # Sync all packages from shared.packages"
      echo "  $0 --tier edge yay          # Sync only the yay package to edge/"
      echo "  $0 --tier shared cursor-bin # Sync only cursor-bin to shared/"
      exit 0
      ;;
    *)
      SPECIFIC_PACKAGES+=("$1")
      shift
      ;;
  esac
done

# Require tier
if [[ -z "$TIER" ]]; then
  print_error "Missing required --tier argument"
  echo "Usage: $0 --tier <edge|shared> [PACKAGE...]"
  exit 1
fi

# Set paths based on tier
PACKAGES_FILE="$BUILD_ROOT/build/packages/${TIER}.packages"
TARGET_DIR="$PKGBUILDS_DIR/$TIER"

print_header "AUR Package Sync (tier: $TIER)"

mkdir -p "$TARGET_DIR"

if [[ ! -f "$PACKAGES_FILE" ]]; then
  print_error "Package list not found: $PACKAGES_FILE"
  exit 1
fi

SYNCED=0
FAILED=0
SYNCED_PACKAGES=()

# Function to sync a package from AUR
sync_package() {
  local package="$1"
  
  print_info "Syncing $package from AUR..."
  
  cd "$TEMP_DIR"
  rm -rf "$package"
  
  if git clone "https://aur.archlinux.org/${package}.git" 2>/dev/null; then
    # Create target directory if it doesn't exist
    mkdir -p "$TARGET_DIR/$package"
    
    # Copy files (not .git directory)
    cp -r "$package"/* "$TARGET_DIR/$package/" 2>/dev/null || true
    cp -r "$package"/.* "$TARGET_DIR/$package/" 2>/dev/null || true
    
    # Remove .git from destination
    rm -rf "$TARGET_DIR/$package/.git"
    
    SYNCED_PACKAGES+=("$package")
    ((SYNCED++))
  else
    print_warning "Failed to clone $package (may not exist in AUR)"
    ((FAILED++))
  fi
}

# If specific packages provided, sync only those
if [[ ${#SPECIFIC_PACKAGES[@]} -gt 0 ]]; then
  for package in "${SPECIFIC_PACKAGES[@]}"; do
    sync_package "$package"
  done
else
  # Sync all packages from list
  while IFS= read -r line || [ -n "$line" ]; do
    [[ "$line" =~ ^#.*$ ]] && continue
    [[ -z "$line" ]] && continue

    package=$(echo "$line" | awk '{print $1}')
    
    # Skip GitHub repos (contain /)
    if [[ "$package" == *"/"* ]]; then
      continue
    fi
    
    sync_package "$package"
  done < <(grep -v "^#" "$PACKAGES_FILE" | grep -v "^$")
fi

# Apply patches only to packages that were actually synced
for package in "${SYNCED_PACKAGES[@]}"; do
  if [[ -d "$TARGET_DIR/$package/patches" ]]; then
    print_info "Applying patches for $package..."
    (cd "$TARGET_DIR/$package" && shopt -s nullglob && for patch in patches/*.patch; do 
      if ! patch -p1 --no-backup-if-mismatch < "$patch"; then
        print_error "Failed to apply patch: $patch"
        exit 1
      fi
    done)
  fi
done

# Apply pkgrel overrides (version-pinned pkgrel bumps that self-clean)
for package in "${SYNCED_PACKAGES[@]}"; do
  override_file="$TARGET_DIR/$package/pkgrel.override"
  [[ -f "$override_file" ]] || continue

  pkgbuild="$TARGET_DIR/$package/PKGBUILD"
  srcinfo="$TARGET_DIR/$package/.SRCINFO"
  gitignore="$TARGET_DIR/$package/.gitignore"
  current_pkgver=$(grep -m1 '^pkgver=' "$pkgbuild" | cut -d= -f2)
  matched=false

  while IFS='=' read -r ver rel; do
    [[ "$ver" =~ ^#.*$ || -z "$ver" ]] && continue
    if [[ "$current_pkgver" == "$ver" ]]; then
      print_info "Applying pkgrel override for $package: pkgver=$ver -> pkgrel=$rel"
      sed -i "s/^pkgrel=.*/pkgrel=$rel/" "$pkgbuild"
      sed -i "s/pkgrel = .*/pkgrel = $rel/" "$srcinfo"
      # Ensure .gitignore tracks the override file (AUR may have overwritten it)
      if [[ -f "$gitignore" ]] && ! grep -q '^!pkgrel.override$' "$gitignore"; then
        echo '!pkgrel.override' >> "$gitignore"
      fi
      matched=true
      break
    fi
  done < "$override_file"

  if [[ "$matched" == false ]]; then
    print_info "Removing stale pkgrel.override for $package (no match for pkgver=$current_pkgver)"
    rm "$override_file"
  fi
done

echo ""
print_success "Sync complete! (tier: $TIER)"
echo "  Target: $TARGET_DIR"
echo "  Synced: $SYNCED"
echo "  Failed: $FAILED"
