#!/bin/bash

BUILD_ROOT=$(realpath "${BASH_SOURCE[0]%/*}/..")
source "$BUILD_ROOT/helpers/message-helpers.sh"
source "$BUILD_ROOT/helpers/paths.sh"

PACKAGES_FILE="$BUILD_ROOT/build/packages/omarchy-aur.packages"
TEMP_DIR=$(mktemp -d)

trap "rm -rf $TEMP_DIR" EXIT

# Parse arguments
SPECIFIC_PACKAGES=()
for arg in "$@"; do
  case "$arg" in
    -h|--help)
      echo "Usage: $0 [PACKAGE...]"
      echo ""
      echo "Sync AUR packages to pkgbuilds/ directory"
      echo ""
      echo "Arguments:"
      echo "  PACKAGE    One or more package names to sync (optional)"
      echo ""
      echo "Examples:"
      echo "  $0              # Sync all packages from omarchy-aur.packages"
      echo "  $0 yay          # Sync only the yay package"
      echo "  $0 yay paru     # Sync yay and paru packages"
      exit 0
      ;;
    *)
      SPECIFIC_PACKAGES+=("$arg")
      ;;
  esac
done

print_header "AUR Package Sync"

mkdir -p "$PKGBUILDS_DIR"

if [[ ! -f "$PACKAGES_FILE" ]]; then
  print_error "Package list not found: $PACKAGES_FILE"
  exit 1
fi

SYNCED=0
FAILED=0

# Function to sync a package from AUR
sync_package() {
  local package="$1"

  print_info "Syncing $package from AUR..."

  # Query AUR API to get PackageBase (handles split packages)
  local api_response=$(curl -s "https://aur.archlinux.org/rpc/v5/info?arg[]=${package}")
  local pkgbase=$(echo "$api_response" | grep -o '"PackageBase":"[^"]*"' | head -1 | cut -d'"' -f4)

  # If API query failed or package not found, try direct clone
  if [[ -z "$pkgbase" ]]; then
    pkgbase="$package"
  fi

  cd "$TEMP_DIR"
  rm -rf "$pkgbase" "$package"

  # Clone the base package
  local clone_output=$(git clone "https://aur.archlinux.org/${pkgbase}.git" 2>&1)
  if echo "$clone_output" | grep -q "Cloning into"; then
    # Verify PKGBUILD exists
    if [[ ! -f "$pkgbase/PKGBUILD" ]]; then
      print_warning "Failed: $pkgbase has no PKGBUILD"
      ((FAILED++))
      return
    fi

    # Remove existing directory to avoid nesting issues
    rm -rf "$PKGBUILDS_DIR/$package"

    # If this is a split package (pkgbase != package), copy with the package name
    if [[ "$pkgbase" != "$package" ]]; then
      print_info "  Split package detected: $package from $pkgbase"
      cp -r "$pkgbase" "$package"
      mv "$package" "$PKGBUILDS_DIR/"
    else
      # Move the cloned directory directly
      mv "$pkgbase" "$PKGBUILDS_DIR/"
    fi

    # Remove .git from destination
    rm -rf "$PKGBUILDS_DIR/$package/.git"

    ((SYNCED++))
  else
    print_warning "Failed to clone $pkgbase (may not exist in AUR)"
    ((FAILED++))
  fi
}

# If specific packages provided, sync only those
if [[ ${#SPECIFIC_PACKAGES[@]} -gt 0 ]]; then
  for package in "${SPECIFIC_PACKAGES[@]}"; do
    sync_package "$package"
  done
else
  # Sync all packages from list
  while IFS= read -r line || [ -n "$line" ]; do
    [[ "$line" =~ ^#.*$ ]] && continue
    [[ -z "$line" ]] && continue

    package=$(echo "$line" | awk '{print $1}')

    # Skip GitHub repos (contain /)
    if [[ "$package" == *"/"* ]]; then
      continue
    fi

    sync_package "$package"
  done < <(grep -v "^#" "$PACKAGES_FILE" | grep -v "^$")
fi

# Apply patches for packages that have them
cd "$PKGBUILDS_DIR"
for dir in */; do
  if [[ -d "$dir/patches" ]]; then
    print_info "Applying patches for $dir..."
    (cd "$dir" && shopt -s nullglob && for patch in patches/*.patch; do 
      if ! patch -p1 --no-backup-if-mismatch < "$patch"; then
        print_error "Failed to apply patch: $patch"
        exit 1
      fi
    done)
  fi
done

echo ""
print_success "Sync complete!"
echo "  Synced: $SYNCED"
echo "  Failed: $FAILED"
